<script src="../js/lib.js"></script>
<script>
    /*
    합병(=merge) 정렬
    정렬이 이미 되어 있는 두개의 배열을 하나로 합치고, 오름차순으로..
    배열의 길이보다 index가 작은동안.
    */
    let arr = [1, 4, 7];     
    let arr2 = [2, 5, 8];

    let len = arr.length + arr2.length; //두 배열의 길이의 합 6
    let mergeArray= new Array(len); //길이가 6인 배열
    console.log("합병 처음 결과 ", mergeArray);
    let idx1=0; //arr 배열의 현재 index
    let idx2=0; //arr2 배열의 현재 index
    let idxM=0; //합병될 배열의 현재 index
    
    while(idx1 < arr.length && idx2 < arr2.length){ //첫째 배열과 , 둘째 배열의 index 가 자신들의  길이보다 작은 동안만 비교 가능.. 둘다 true일 경우
        //두 배열 간 비교 시작하기
        if(arr[idx1] < arr2[idx2]){
            mergeArray[idxM]=arr[idx1];
            idx1++;
            idxM++;
        } else{
            mergeArray[idxM]=arr2[idx2];
            idx2++;
            idxM++;
        }
    }

    console.log("합병 중간 결과 ", mergeArray);

    /*
    while문이 and 조건으로 되어 있으므로, 두 개의 배열 중 먼저 도착하는 index에 의해
    while문이 멈추고, 마저 들어가지 못하는 나머지가 생겨버린다. (반드시)
    누가 남았는지 잡아내서 합병 배열에 넣어버린다

    두개의 배열의 현재 index 위치를 표현하는 idx1과 idx2 중 누가 먼저 도달했는지 알수가
    없으므로, 둘 다 를 대상으로, 배열의 index가 길이에 도달하지 못했다면 합병배열에
    넣는 코드 작성

    아래의 코드에서 while 문을 두번 쓴 이유? 누가 먼저 도달했는지 모르니깐..
    */
    while(idx1 < arr.length)mergeArray[idxM++] = arr[idx1++];
    while(idx2 < arr2.length)mergeArray[idxM++] = arr2[idx2++];

    console.log("합병 마지막 결과 ", mergeArray);


</script>